package com.bean;


import com.handler.DSGHandler;
import com.handler.SQLHandler;
import io.netty.channel.ChannelHandlerContext;

import java.sql.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

import static com.handler.IOHandler.*;

public class WrapStatement implements AutoCloseable {

    final AtomicInteger COUNTER = new AtomicInteger(1);

    private final WrapConnect wrapConnect;
    final String id;
    private final String user;

    private String latest_execute_rs;
    private int latest_execute_update = -1;

    private Statement statement;

    ConcurrentMap<String, WrapResultSet> rsMap = new ConcurrentHashMap<>(1);

    WrapStatement(WrapConnect wrapConnect, String id, String user, Statement statement) {
        this.wrapConnect = wrapConnect;
        this.id = id;
        this.user = user;
        this.statement = statement;
    }

    public String getUser() {
        return user;
    }

    public WrapConnect getWrapConnect() {
        return wrapConnect;
    }

    public void getResultSet(ChannelHandlerContext out) throws SQLException {
        if (latest_execute_rs == null || !rsMap.containsKey(latest_execute_rs)) {
            out.write(writeByte(OK));
            out.write(writeShort(-1));
        } else {
            WrapResultSet wrs = rsMap.get(latest_execute_rs);
            out.write(writeShortStr(OK, latest_execute_rs));
            wrs.getMetaData(out);
            wrs.next(true, out);
            latest_execute_rs = null; //This method should be called only once per result
        }
    }

    public int getUpdateCount() {
        int i = latest_execute_update;
        latest_execute_update = -1;
        return i;
    }

    public boolean getMoreResults() {
        return latest_execute_rs != null && rsMap.containsKey(latest_execute_rs);
    }

    public WrapResultSet getResultSet(String resultSetId) {
        return rsMap.get(resultSetId);
    }

    private SQLStruct checkPermission(String sql) throws Exception {
        SQLHandler sqlHandler = new SQLHandler(wrapConnect, user, sql);
        sqlHandler.handler();
        SQLStruct sqlStruct = sqlHandler.getSqlStruct();
        DSGHandler.checkPermission(wrapConnect.getAppid(), wrapConnect.getPlatform_id(), user, sqlStruct);
        return sqlStruct;
    }

    private String executeQuery(String sql) throws Exception {
        SQLStruct sqlStruct = this.checkPermission(sql);
        ResultSet rs = this.statement.executeQuery(sql);
        String rsId = this.id + COUNTER.incrementAndGet();
        WrapResultSet wrs = new WrapResultSet(this, rsId, rs, sqlStruct);
        rsMap.put(rsId, wrs);
        return rsId;
    }

    public void executeQuery(String sql, ChannelHandlerContext out) throws Exception {
        String rsId = this.executeQuery(sql);
        WrapResultSet wrs = rsMap.get(rsId);
        out.write(writeShortStr(OK, rsId));
        wrs.getMetaData(out);
        wrs.next(true, out);
    }

    public int executeUpdate(String sql, boolean check) throws Exception {
        if (!check) this.checkPermission(sql);
        return this.statement.executeUpdate(sql);
    }

    public int executeUpdate(String sql, int[] columnIndexes, boolean check) throws Exception {
        if (!check) this.checkPermission(sql);
        return this.statement.executeUpdate(sql, columnIndexes);
    }

    public int executeUpdate(String sql, String[] columnNames, boolean check) throws Exception {
        if (!check) this.checkPermission(sql);
        return this.statement.executeUpdate(sql, columnNames);
    }

    public int executeUpdate(String sql, int autoGeneratedKeys, boolean check) throws Exception {
        if (!check) this.checkPermission(sql);
        return this.statement.executeUpdate(sql, autoGeneratedKeys);
    }

    public boolean execute(String sql) throws Exception {
        SQLHandler sqlHandler = new SQLHandler(wrapConnect, user, sql);
        sqlHandler.handler();
        SQLStruct sqlStruct = sqlHandler.getSqlStruct();
        if ("select".equals(sqlStruct.getAction())) this.latest_execute_rs = executeQuery(sql);
        else this.latest_execute_update = this.executeUpdate(sql, true);
        return true;
    }

    public boolean execute(String sql, int autoGeneratedKeys) throws Exception {
        SQLHandler sqlHandler = new SQLHandler(wrapConnect, user, sql);
        sqlHandler.handler();
        SQLStruct sqlStruct = sqlHandler.getSqlStruct();
        if ("select".equals(sqlStruct.getAction())) this.latest_execute_rs = executeQuery(sql);
        else this.latest_execute_update = this.executeUpdate(sql, autoGeneratedKeys, true);
        return true;
    }

    public boolean execute(String sql, int[] columnIndexes) throws Exception {
        SQLHandler sqlHandler = new SQLHandler(wrapConnect, user, sql);
        sqlHandler.handler();
        SQLStruct sqlStruct = sqlHandler.getSqlStruct();
        if ("select".equals(sqlStruct.getAction())) this.latest_execute_rs = executeQuery(sql);
        else this.latest_execute_update = this.executeUpdate(sql, columnIndexes, true);
        return true;
    }

    public boolean execute(String sql, String[] columnNames) throws Exception {
        SQLHandler sqlHandler = new SQLHandler(wrapConnect, user, sql);
        sqlHandler.handler();
        SQLStruct sqlStruct = sqlHandler.getSqlStruct();
        if ("select".equals(sqlStruct.getAction())) this.latest_execute_rs = executeQuery(sql);
        else this.latest_execute_update = this.executeUpdate(sql, columnNames, true);
        return true;
    }

    public void getGeneratedKeys(ChannelHandlerContext out) throws SQLException {
        ResultSet rs = this.statement.getGeneratedKeys();
        String rsId = this.id + COUNTER.incrementAndGet();
        WrapResultSet wrs = new WrapResultSet(this, rsId, rs);
        rsMap.put(rsId, wrs);
        out.write(writeShortStr(OK, rsId));
        wrs.getMetaData(out);
        wrs.next(true, out);
    }

    public int[] executeBatch(String[] sqls) throws Exception {
        if (sqls == null || sqls.length == 0) throw new SQLException("batch sql is null or empty");
        try {
            for (String sql : sqls) {
                this.checkPermission(sql);
                this.statement.addBatch(sql);
            }
        } catch (Exception e) {
            this.statement.clearBatch();
            throw e;
        }
        return this.statement.executeBatch();
    }

    public void setFetchDirection(int direction) throws SQLException {
        this.statement.setFetchDirection(direction);
    }

    int getFetchSize() throws SQLException {
        return this.statement.getFetchSize();
    }

    public void setFetchSize(int rows) throws SQLException {
        this.statement.setFetchSize(rows);
    }


    @Override
    public void close() {
        rsMap.values().forEach(WrapResultSet::close);
        rsMap.clear();
        try {
            if (statement != null) statement.close();
            wrapConnect.stmtMap.invalidate(id);
        } catch (SQLException ignored) {
        }

    }
}
