package com.handler;

import com.audit.AuditEvent;
import com.audit.AuditManager;
import com.bean.WrapStatement;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;

import java.sql.SQLException;
import java.util.Arrays;

import static com.handler.IOHandler.*;

public class StatementHandler {

    public static void handler(WrapStatement statement, ByteBuf src, ChannelHandlerContext out)
            throws Exception {
        String flag = statement.getUser() == null || statement.getUser().isEmpty() ?
                statement.getWrapConnect().getAK() : statement.getUser();
        String mName = IOHandler.readByteLen(src);
        if ("executeQuery".equals(mName)) {
            String sql = readIntLen(src);
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    flag, mName, sql));
            statement.executeQuery(sql, out);
        } else if ("executeUpdate".equals(mName)) {
            short pc = src.readByte();
            String sql = readIntLen(src);
            int count;
            if (1 == pc) {
                AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                        statement.getUser(), mName, sql));
                count = statement.executeUpdate(sql, false);
            } else {
                int arrSize = src.readShort();
                short type = src.readByte();
                if (0 == arrSize) {
                    if (0 != type) throw new SQLException("executeUpdate[autoGeneratedKeys] type[" +
                            type + "] error");
                    int v = src.readInt();
                    AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                            statement.getUser(), mName, sql, v));
                    count = statement.executeUpdate(sql, v, false);
                } else {
                    if (0 == type) {
                        int[] columnIndexes = readInt(arrSize, src);
                        AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                                statement.getUser(), mName, sql, Arrays.toString(columnIndexes)));
                        count = statement.executeUpdate(sql, columnIndexes, false);
                    } else if (1 == type) {
                        String[] columnNames = readShortLen(arrSize, src);
                        AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                                statement.getUser(), mName, sql, Arrays.toString(columnNames)));
                        count = statement.executeUpdate(sql, columnNames, false);
                    } else throw new SQLException("executeUpdate[array] type[" + type + "] error");
                }
            }
            out.write(writeInt(OK, count));
        } else if ("execute".equals(mName)) {
            short pc = src.readByte();
            String sql = readIntLen(src);
            boolean bool;
            if (1 == pc) {
                AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                        statement.getUser(), mName, sql));
                bool = statement.execute(sql);
            } else {
                int arrSize = src.readShort();
                short type = src.readByte();
                if (0 == arrSize) {
                    if (0 != type) throw new SQLException("execute[autoGeneratedKeys] type[" + type + "] error");
                    int v = src.readInt();
                    AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                            statement.getUser(), mName, sql, v));
                    bool = statement.execute(sql, v);
                } else {
                    if (0 == type) {
                        int[] columnIndexes = readInt(arrSize, src);
                        AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                                statement.getUser(), mName, sql, Arrays.toString(columnIndexes)));
                        bool = statement.execute(sql, columnIndexes);
                    } else if (1 == type) {
                        String[] columnNames = readShortLen(arrSize, src);
                        AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                                statement.getUser(), mName, sql, Arrays.toString(columnNames)));
                        bool = statement.execute(sql, columnNames);
                    } else throw new SQLException("execute[array] type[" + type + "] error");
                }
            }
            out.write(writeShortStr(OK, bool));
        } else if ("getGeneratedKeys".equals(mName)) {
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), mName));
            statement.getGeneratedKeys(out);
        } else if ("executeBatch".equals(mName)) {
            int arrSize = src.readShort();
            short type = src.readByte();
            if (1 != type) throw new SQLException("executeBatch param type[" + type + "] error");
            String[] sqls = readIntLen(arrSize, src);
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), mName, Arrays.toString(sqls)));
            int[] code = statement.executeBatch(sqls);
            out.write(writeInt(OK, code));
        } else if ("setFetchDirection".equals(mName)) {
            int v = src.readInt();
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), mName, v));
            statement.setFetchDirection(v);
            out.write(writeByte(OK));
        } else if ("setFetchSize".equals(mName)) {
            int v = src.readInt();
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), mName, v));
            statement.setFetchSize(v);
            out.write(writeByte(OK));
        } else if ("getResultSet".equals(mName)) {
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), mName));
            statement.getResultSet(out);
        } else if ("close".equals(mName)) {
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), "statement=>" + mName));
            statement.close();
            out.write(writeByte(OK));
        } else if ("getUpdateCount".equals(mName)) {
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), "statement=>" + mName));
            out.write(writeInt(OK, statement.getUpdateCount()));
        } else if ("getMoreResults".equals(mName)) {
            AuditManager.getInstance().audit(new AuditEvent(statement.getWrapConnect().getAddress(),
                    statement.getUser(), "statement=>" + mName));
            out.write(writeShortStr(OK, statement.getMoreResults()));
        } else throw new SQLException("statementMethod[" + mName + "] is not support");
    }
}
